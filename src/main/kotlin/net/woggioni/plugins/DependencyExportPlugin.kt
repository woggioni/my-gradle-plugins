/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.woggioni.plugins

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.component.ModuleComponentIdentifier
import org.gradle.api.artifacts.component.ProjectComponentIdentifier
import org.gradle.api.artifacts.result.ResolvedComponentResult
import org.gradle.api.artifacts.result.ResolvedDependencyResult
import org.gradle.api.artifacts.result.UnresolvedDependencyResult
import java.io.BufferedWriter
import java.io.OutputStreamWriter
import java.nio.file.Files

open class DependencyExportPluginExtension {
    var configurationName: String = "default"
}

object DependencyExporter {

    fun graphviz(project: Project, configurationName : String) {
        var sequence = 0
        val map = HashMap<ResolvedComponentResult, Int>()
        val resolutionResult = project.configurations.single {
            it.name == configurationName
        }.incoming.resolutionResult
        project.buildDir.toPath().let {
            Files.createDirectories(it)
        }.let {
            BufferedWriter(
                    OutputStreamWriter(
                            Files.newOutputStream(project.buildDir.toPath().resolve("dependencies.dot"))))
        }.use { writer ->
            writer.write("digraph G {")
            writer.newLine()
            writer.write("    #rankdir=\"LR\";")
            writer.newLine()
            for (component in resolutionResult.allComponents) {
                map.computeIfAbsent(component) {
                    sequence++
                }
                val (shape, color) = when (component.id) {
                    is ProjectComponentIdentifier -> "box" to "#88ff88"
                    is ModuleComponentIdentifier -> "oval" to "#ffff88"
                    else -> throw NotImplementedError("${component.id::class}")
                }
                val attrs = mapOf(
                    "label" to component.id.displayName,
                    "shape" to shape,
                    "style" to "filled",
                    "fillcolor" to color
                )
                writer.write("    node_${map[component]} [" +
                        attrs.entries
                            .asSequence()
                            .map { "${it.key}=\"${it.value}\"" }.joinToString(", ") +
                        "];")
                writer.newLine()
            }

            for (component in resolutionResult.allComponents) {

                component.dependencies.map { dependency ->
                    when (dependency) {
                        is ResolvedDependencyResult -> dependency
                        is UnresolvedDependencyResult -> {
                            throw dependency.failure
                        }
                        else -> {
                            throw NotImplementedError("${dependency::class}")
                        }
                    }
                }.map(ResolvedDependencyResult::getSelected).forEach { child ->
                    writer.write("    node_${map[component]} -> node_${map[child]};")
                    writer.newLine()
                }
            }
            writer.write("}")
            writer.newLine()
        }
    }
}

class DependencyExportPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        val extension = DependencyExportPluginExtension()
        project.extensions.add(DependencyExportPluginExtension::class.java, "exportDependencies", extension)
        project.tasks.register("exportDependencies") {
            it.doLast {
                val propertyKey = "exportDependencies.configurationName"
                val properties = project.properties
                val configurationName = properties.getOrDefault(propertyKey, extension.configurationName) as String
                DependencyExporter.graphviz(project, configurationName = configurationName)
            }
        }
    }
}