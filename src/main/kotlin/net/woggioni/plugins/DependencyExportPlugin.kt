/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.woggioni.plugins

import net.woggioni.jwo.JWO
import net.woggioni.jwo.tree.StackContext
import net.woggioni.jwo.tree.TreeNode
import net.woggioni.jwo.tree.TreeNodeVisitor
import net.woggioni.jwo.tree.TreeWalker
import net.woggioni.worth.serialization.json.JSONDumper
import net.woggioni.worth.value.ObjectValue
import net.woggioni.worth.xface.Value
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.component.ModuleComponentIdentifier
import org.gradle.api.artifacts.component.ProjectComponentIdentifier
import org.gradle.api.artifacts.result.ResolvedComponentResult
import org.gradle.api.artifacts.result.ResolvedDependencyResult
import org.gradle.api.artifacts.result.UnresolvedDependencyResult
import java.io.BufferedWriter
import java.io.OutputStreamWriter
import java.nio.file.Files
import java.nio.file.Paths

open class DependencyExportPluginExtension {
    var configurationName: String = "default"
}

object DependencyExporter {

    fun graphviz(project: Project, configurationName : String) {
        var sequence = 0
        val map = HashMap<ResolvedComponentResult, Int>()
        val resolutionResult = project.configurations.single {
            it.name == configurationName
        }.incoming.resolutionResult
        project.buildDir.toPath().let {
            Files.createDirectories(it)
        }.let {
            BufferedWriter(
                    OutputStreamWriter(
                            Files.newOutputStream(project.buildDir.toPath().resolve("dependencies.dot"))))
        }.use { writer ->
            writer.write("digraph G {")
            writer.newLine()
            writer.write("    #rankdir=\"LR\";")
            writer.newLine()
            for (component in resolutionResult.allComponents) {
                map.computeIfAbsent(component) {
                    sequence++
                }
                val (shape, color) = when (component.id) {
                    is ProjectComponentIdentifier -> "box" to "#88ff88"
                    is ModuleComponentIdentifier -> "oval" to "#ffff88"
                    else -> throw NotImplementedError("${component.id::class}")
                }
                val attrs = mapOf(
                    "label" to component.id.displayName,
                    "shape" to shape,
                    "style" to "filled",
                    "fillcolor" to color
                )
                writer.write("    node_${map[component]} [" +
                        attrs.entries
                            .asSequence()
                            .map { "${it.key}=\"${it.value}\"" }.joinToString(", ") +
                        "];")
                writer.newLine()
            }

            for (component in resolutionResult.allComponents) {

                component.dependencies.map { dependency ->
                    when (dependency) {
                        is ResolvedDependencyResult -> dependency
                        is UnresolvedDependencyResult -> {
                            throw dependency.failure
                        }
                        else -> {
                            throw NotImplementedError("${dependency::class}")
                        }
                    }
                }.map(ResolvedDependencyResult::getSelected).forEach { child ->
                    writer.write("    node_${map[component]} -> node_${map[child]};")
                    writer.newLine()
                }
            }
            writer.write("}")
            writer.newLine()
        }
    }
}

class DependencyTreeNode(val component: ResolvedComponentResult) : TreeNode<DependencyTreeNode> {
    override fun children(): Iterator<DependencyTreeNode> {
        return object : Iterator<DependencyTreeNode> {
            val it = component.dependencies.iterator()
            override fun hasNext(): Boolean {
                return it.hasNext()
            }

            override fun next(): DependencyTreeNode {
                val dependency = it.next()
                return when (dependency) {
                    is ResolvedDependencyResult -> {
                        DependencyTreeNode(dependency.selected)
                    }
                    is UnresolvedDependencyResult -> {
                        throw dependency.failure
                    }
                    else -> {
                        throw NotImplementedError("${dependency::class}")
                    }
                }
            }
        }
    }
}

fun export(project: Project) {
    val cfg = Value.Configuration.builder()
            .serializeReferences(true)
            .objectValueImplementation(ObjectValue.Implementation.ArrayList)
            .build()
    val result = ObjectValue.newInstance(cfg)
    project.configurations.all { configuration ->
        if (configuration.isCanBeResolved) {
            val configDeps = ObjectValue.newInstance(cfg)
            val visitor = object : TreeNodeVisitor<DependencyTreeNode, ObjectValue> {
                override fun visitPre(stack: MutableList<StackContext<DependencyTreeNode, ObjectValue>>): TreeNodeVisitor.VisitOutcome {
                    val stackElement = JWO.tail(stack)
                    stackElement.context = ObjectValue.newInstance(cfg)
                    val id = stackElement.node.component.id
                    if (stack.size == 1) {
                        configDeps.put(id.displayName, stackElement.context)
                    } else if (stack.size > 1) {
                        val parentStackElement = JWO.tail(stack, -2)
                        parentStackElement.context.put(id.displayName, stackElement.context)
                    }
                    return TreeNodeVisitor.VisitOutcome.CONTINUE
                }
//                    override fun visitPost(stack: MutableList<StackContext<DependencyTreeNode, ObjectValue>>?) {
//                        val stackElement = JWO.tail(stack)
//                        if(stack.size > 1) {
//                            val parentStackElement = JWO.tail(stack, -2)
//                            parentStackElement.context.add(StringValue(stackElement.node.component.toString()))
//                        }
//                    }
            }
            TreeWalker(visitor).walk(DependencyTreeNode(configuration.incoming.resolutionResult.root))
            result.put(configuration.name, configDeps)
        }
    }
    BufferedWriter(OutputStreamWriter(Files.newOutputStream(Paths.get("/tmp/dependencies.json")))).use {
        JSONDumper.newInstance(cfg).dump(result, it)
    }
}

class DependencyExportPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        val extension = DependencyExportPluginExtension()
        project.extensions.add(DependencyExportPluginExtension::class.java, "exportDependencies", extension)
        project.tasks.register("exportDependencies") {
            it.doLast {
                val propertyKey = "exportDependencies.configurationName"
                val properties = project.properties
                val configurationName = properties.getOrDefault(propertyKey, extension.configurationName) as String
                DependencyExporter.graphviz(project, configurationName = configurationName)
            }
        }
    }
}